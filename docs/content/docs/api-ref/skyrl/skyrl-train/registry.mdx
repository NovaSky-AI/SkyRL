---
title: "Algorithm Registry"
description: "Algorithm Registry API - Register custom algorithm functions."
---


## Base Registry Classes


The registry system provides a way to register and manage custom algorithm functions across distributed Ray environments.

### <span className="bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">class</span> `BaseFunctionRegistry`

Base class for function registries with Ray actor synchronization.

**Functions:**

Name | Description
---- | -----------
[`__init_subclass__`](#method-__init_subclass__) |
[`_get_or_create_actor`](#method-classmethod-_get_or_create_actor) | Get or create the Ray actor for managing the registry using get_if_exists.
[`_sync_local_to_actor`](#method-classmethod-_sync_local_to_actor) | Sync all local functions to Ray actor.
[`sync_with_actor`](#method-classmethod-sync_with_actor) | Sync local registry with Ray actor if Ray is available.
[`register`](#method-classmethod-register) | Register a function.
[`get`](#method-classmethod-get) | Get a function by name.
[`list_available`](#method-classmethod-list_available) | List all registered functions.
[`unregister`](#method-classmethod-unregister) | Unregister a function. Useful for testing.
[`reset`](#method-classmethod-reset) | Resets the registry (useful for testing purposes).
[`repopulate`](#method-classmethod-repopulate) | Repopulate the registry with the default functions.

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> `__init_subclass__`

```python
__init_subclass__(**kwargs)
```


<details>
<summary>Source code in `skyrl_train/utils/ppo_utils.py:232-236`</summary>

```python
    def __init_subclass__(cls, **kwargs):
        super().__init_subclass__(**kwargs)
        cls._functions = {}
        cls._ray_actor = None
        cls._synced_to_actor = False
```

</details>

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> <span className="bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">classmethod</span> `_get_or_create_actor`

```python
_get_or_create_actor()
```

Get or create the Ray actor for managing the registry using get_if_exists.


<details>
<summary>Source code in `skyrl_train/utils/ppo_utils.py:238-247`</summary>

```python
    @classmethod
    def _get_or_create_actor(cls):
        """Get or create the Ray actor for managing the registry using get_if_exists."""
        if not ray.is_initialized():
            raise Exception("Ray is not initialized, cannot create registry actor")

        if cls._ray_actor is None:
            # Use get_if_exists to create actor only if it doesn't exist
            cls._ray_actor = RegistryActor.options(name=cls._actor_name, get_if_exists=True).remote()
        return cls._ray_actor
```

</details>

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> <span className="bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">classmethod</span> `_sync_local_to_actor`

```python
_sync_local_to_actor()
```

Sync all local functions to Ray actor.


<details>
<summary>Source code in `skyrl_train/utils/ppo_utils.py:249-266`</summary>

```python
    @classmethod
    def _sync_local_to_actor(cls):
        """Sync all local functions to Ray actor."""
        if cls._synced_to_actor:
            return
        if not ray.is_initialized():
            raise Exception("Ray is not initialized, cannot sync with actor")

        try:
            actor = cls._get_or_create_actor()
            if actor is not None:
                for name, func in cls._functions.items():
                    func_serialized = cloudpickle.dumps(func)
                    ray.get(actor.register.remote(name, func_serialized))
                cls._synced_to_actor = True
        except Exception as e:
            logger.error(f"Error syncing {cls._function_type} to actor: {e}")
            raise e
```

</details>

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> <span className="bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">classmethod</span> `sync_with_actor`

```python
sync_with_actor()
```

Sync local registry with Ray actor if Ray is available.


<details>
<summary>Source code in `skyrl_train/utils/ppo_utils.py:268-306`</summary>

```python
    @classmethod
    def sync_with_actor(cls):
        """Sync local registry with Ray actor if Ray is available."""
        # Only try if Ray is initialized
        if not ray.is_initialized():
            raise Exception("Ray is not initialized, cannot sync with actor")

        # First check if the actor is still alive
        # NOTE(Charlie): This is mainly for unit tests, where we run multiple unit tests in the
        # same Python process, and each unit test has ray init/shutdown. This makes cls's attributes
        # outdated (e.g. the _ray_actor points to a stale actor in the previous ray session).
        try:
            _ = ray.get_actor(cls._actor_name)  # this raises exception if the actor is stale
        except ValueError:
            cls._ray_actor = None
            cls._synced_to_actor = False

        # First, sync our local functions to the actor
        cls._sync_local_to_actor()

        actor = cls._get_or_create_actor()
        if actor is None:
            return

        available = ray.get(actor.list_available.remote())

        # Sync any new functions from actor to local registry
        for name in available:
            if name not in cls._functions:
                func_serialized = ray.get(actor.get.remote(name))
                if func_serialized is not None:
                    # Deserialize the function
                    try:
                        func = cloudpickle.loads(func_serialized)
                        cls._functions[name] = func
                    except Exception as e:
                        # If deserialization fails, skip this function
                        logger.error(f"Error deserializing {name} from actor: {e}")
                        raise e
```

</details>

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> <span className="bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">classmethod</span> `register`

```python
register(name: Union[str, StrEnum], func: Callable)
```

Register a function.

If ray is initialized, this function will get or create a named ray actor (RegistryActor)
for the registry, and sync the registry to the actor.

If ray is not initalized, the function will be stored in the local registry only.

To make sure all locally registered functions are available to all ray processes,
call sync_with_actor() after ray.init().

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`name` | Union\[str, StrEnum\] | Name of the function to register. Can be a string or a StrEnum. | *required*
`func` | Callable | Function to register. | *required*

**Raises:**

Type | Description
---- | -----------
ValueError| If the function is already registered.


<details>
<summary>Source code in `skyrl_train/utils/ppo_utils.py:308-344`</summary>

```python
    @classmethod
    def register(cls, name: Union[str, StrEnum], func: Callable):
        """Register a function.

        If ray is initialized, this function will get or create a named ray actor (RegistryActor)
        for the registry, and sync the registry to the actor.

        If ray is not initalized, the function will be stored in the local registry only.

        To make sure all locally registered functions are available to all ray processes,
        call sync_with_actor() after ray.init().

        Args:
            name: Name of the function to register. Can be a string or a StrEnum.
            func: Function to register.

        Raises:
            ValueError: If the function is already registered.
        """
        # Convert enum to string if needed
        # note: StrEnum is not cloudpickleable: https://github.com/cloudpipe/cloudpickle/issues/558
        if isinstance(name, StrEnum):
            name = name.value

        if name in cls._functions:
            raise ValueError(f"{cls._function_type} '{name}' already registered")

        # Always store in local registry first
        cls._functions[name] = func

        # Try to sync with Ray actor if Ray is initialized
        if ray.is_initialized():
            actor = cls._get_or_create_actor()
            if actor is not None:
                # Serialize the function using cloudpickle
                func_serialized = cloudpickle.dumps(func)
                ray.get(actor.register.remote(name, func_serialized))
```

</details>

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> <span className="bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">classmethod</span> `get`

```python
get(name: str) -> Callable
```

Get a function by name.

If ray is initialized, this function will first sync the local registry with the RegistryActor.
Then it will return the function if it is found in the registry.

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`name` | str | Name of the function to get. Can be a string or a StrEnum. | *required*

**Returns:**

Type | Description
---- | -----------
Callable | The function if it is found in the registry.


<details>
<summary>Source code in `skyrl_train/utils/ppo_utils.py:346-366`</summary>

```python
    @classmethod
    def get(cls, name: str) -> Callable:
        """Get a function by name.

        If ray is initialized, this function will first sync the local registry with the RegistryActor.
        Then it will return the function if it is found in the registry.

        Args:
            name: Name of the function to get. Can be a string or a StrEnum.

        Returns:
            The function if it is found in the registry.
        """
        # Try to sync with actor first if Ray is available
        if ray.is_initialized():
            cls.sync_with_actor()

        if name not in cls._functions:
            available = list(cls._functions.keys())
            raise ValueError(f"Unknown {cls._function_type.lower()} '{name}'. Available: {available}")
        return cls._functions[name]
```

</details>

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> <span className="bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">classmethod</span> `list_available`

```python
list_available() -> List[str]
```

List all registered functions.


<details>
<summary>Source code in `skyrl_train/utils/ppo_utils.py:368-374`</summary>

```python
    @classmethod
    def list_available(cls) -> List[str]:
        """List all registered functions."""
        # Try to sync with actor first if Ray is available
        if ray.is_initialized():
            cls.sync_with_actor()
        return list(cls._functions.keys())
```

</details>

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> <span className="bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">classmethod</span> `unregister`

```python
unregister(name: Union[str, StrEnum])
```

Unregister a function. Useful for testing.


<details>
<summary>Source code in `skyrl_train/utils/ppo_utils.py:376-407`</summary>

```python
    @classmethod
    def unregister(cls, name: Union[str, StrEnum]):
        """Unregister a function. Useful for testing."""
        # Convert enum to string if needed
        if isinstance(name, StrEnum):
            name = name.value

        # Try to sync with actor first to get any functions that might be in the actor but not local
        if ray.is_initialized():
            cls.sync_with_actor()

        # Track if we found the function anywhere
        found_locally = name in cls._functions
        found_in_actor = False

        # Remove from local registry if it exists
        if found_locally:
            del cls._functions[name]

        # Try to remove from Ray actor if Ray is available
        if ray.is_initialized():
            actor = cls._get_or_create_actor()
            if actor is not None:
                # Check if it exists in actor first
                available_in_actor = ray.get(actor.list_available.remote())
                if name in available_in_actor:
                    found_in_actor = True
                    ray.get(actor.unregister.remote(name))

        # Only raise error if the function wasn't found anywhere
        if not found_locally and not found_in_actor:
            raise ValueError(f"{cls._function_type} '{name}' not registered")
```

</details>

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> <span className="bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">classmethod</span> `reset`

```python
reset()
```

Resets the registry (useful for testing purposes).


<details>
<summary>Source code in `skyrl_train/utils/ppo_utils.py:409-420`</summary>

```python
    @classmethod
    def reset(cls):
        """Resets the registry (useful for testing purposes)."""
        if ray.is_initialized() and cls._ray_actor is not None:
            try:
                actor = ray.get_actor(cls._actor_name)  # this raises exception if the actor is stale
                ray.kill(actor)
            except ValueError:
                pass  # Actor may already be gone
        cls._functions.clear()
        cls._ray_actor = None
        cls._synced_to_actor = False
```

</details>

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> <span className="bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">classmethod</span> `repopulate`

```python
repopulate()
```

Repopulate the registry with the default functions.


<details>
<summary>Source code in `skyrl_train/utils/ppo_utils.py:422-426`</summary>

```python
    @classmethod
    def repopulate(cls):
        """Repopulate the registry with the default functions."""
        cls.reset()
        cls.register(cls._function_type, cls._function_type)
```

</details>

### <span className="bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">class</span> `RegistryActor`

```python
RegistryActor()
```

Shared Ray actor for managing function registries across processes.

**Functions:**

Name | Description
---- | -----------
[`__init__`](#method-__init__) |
[`register`](#method-register) | Register a serialized function.
[`get`](#method-get) | Get a serialized function by name.
[`list_available`](#method-list_available) | List all available function names.
[`unregister`](#method-unregister) | Unregister a function by name.

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> <span className="bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">classmethod</span> `register`

```python
register(name: str, func_serialized: bytes)
```

Register a serialized function.


<details>
<summary>Source code in `skyrl_train/utils/ppo_utils.py:208-210`</summary>

```python
    def register(self, name: str, func_serialized: bytes):
        """Register a serialized function."""
        self.registry[name] = func_serialized
```

</details>

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> <span className="bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">classmethod</span> `get`

```python
get(name: str)
```

Get a serialized function by name.


<details>
<summary>Source code in `skyrl_train/utils/ppo_utils.py:212-214`</summary>

```python
    def get(self, name: str):
        """Get a serialized function by name."""
        return self.registry.get(name)
```

</details>

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> <span className="bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">classmethod</span> `list_available`

```python
list_available()
```

List all available function names.


<details>
<summary>Source code in `skyrl_train/utils/ppo_utils.py:216-218`</summary>

```python
    def list_available(self):
        """List all available function names."""
        return list(self.registry.keys())
```

</details>

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> <span className="bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">classmethod</span> `unregister`

```python
unregister(name: str)
```

Unregister a function by name.


<details>
<summary>Source code in `skyrl_train/utils/ppo_utils.py:220-222`</summary>

```python
    def unregister(self, name: str):
        """Unregister a function by name."""
        return self.registry.pop(name, None)
```

</details>

### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> `sync_registries`

```python
sync_registries()
```

Sync the registries with the ray actor once ray is initialized


## Advantage Estimator Registry


The advantage estimator registry manages functions that compute advantages and returns.

### <span className="bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">class</span> `AdvantageEstimatorRegistry`

Bases: [BaseFunctionRegistry](#class-basefunctionregistry)

Registry for advantage estimator functions.

This registry allows users to register custom advantage estimators without modifying
the skyrl_train package. Custom estimators can be registered by calling
AdvantageEstimatorRegistry.register() directly or by using the @register_advantage_estimator
decorator.

See examples/algorithms/custom_advantage_estimator for a simple example of how to
register and use custom advantage estimators.

**Functions:**

Name | Description
---- | -----------
[`repopulate_registry`](#method-classmethod-repopulate_registry) |

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> <span className="bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">classmethod</span> `repopulate_registry`

```python
repopulate_registry()
```


<details>
<summary>Source code in `skyrl_train/utils/ppo_utils.py:452-464`</summary>

```python
    @classmethod
    def repopulate_registry(cls):
        ae_avail = set(cls.list_available())
        ae_types = {
            "grpo": [AdvantageEstimator.GRPO, compute_grpo_outcome_advantage],
            "gae": [AdvantageEstimator.GAE, compute_gae_advantage_return],
            "rloo": [AdvantageEstimator.RLOO, compute_rloo_outcome_advantage],
            "reinforce++": [AdvantageEstimator.REINFORCE_PP, compute_reinforce_plus_plus_outcome_advantage],
        }

        for ae_name, (ae_type, ae_func) in ae_types.items():
            if ae_name not in ae_avail:
                cls.register(ae_type, ae_func)
```

</details>

### <span className="bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">class</span> `AdvantageEstimator`

Bases: StrEnum

**Functions:**

Name | Description
---- | -----------
[`__new__`](#__new__) |
[`__format__`](#__format__) | Return a formatted version of the string as described by format_spec.
[`__repr__`](#__repr__) |
[`__str__`](#__str__) | Return str(self).

**Attributes:**

Name | Type | Description
---- | ---- | -----------
[`__doc__`](#__doc__) | | str(object='') -> str
[`__module__`](#__module__) | | str(object='') -> str

#### <span className="bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">attr</span> `__doc__`

```python
__doc__ = '\n    Enum where members are also (and must be) strings\n    '
```

str(object='') -> str
str(bytes_or_buffer\[, encoding[, errors]\]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

#### <span className="bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">attr</span> `__module__`

```python
__module__ = 'enum'
```

str(object='') -> str
str(bytes_or_buffer\[, encoding[, errors]\]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> <span className="bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">staticmethod</span> `__new__`

```python
__new__(value)
```

#### `__format__`

```python
__format__(format_spec)
```

Return a formatted version of the string as described by format_spec.

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> `__repr__`

```python
__repr__()
```

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> `__str__`

```python
__str__()
```

Return str(self).

### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> `register_advantage_estimator`

```python
register_advantage_estimator(name: Union[str, AdvantageEstimator])
```

Decorator to register an advantage estimator function.


## Policy Loss Registry


The policy loss registry manages functions that compute policy losses for PPO.

### <span className="bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">class</span> `PolicyLossRegistry`

Bases: [BaseFunctionRegistry](#class-basefunctionregistry)

Registry for policy loss functions.

This registry allows users to register custom policy loss functions without modifying
the skyrl_train package. Custom functions can be registered by calling
PolicyLossRegistry.register() directly or by using the @register_policy_loss
decorator.

See examples/algorithms/custom_policy_loss for a simple example of how to
register and use custom policy loss functions.

**Functions:**

Name | Description
---- | -----------
[`repopulate_registry`](#method-classmethod-repopulate_registry) | Repopulate the registry with default policy loss functions.

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> <span className="bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">classmethod</span> `repopulate_registry`

```python
repopulate_registry()
```

Repopulate the registry with default policy loss functions.


<details>
<summary>Source code in `skyrl_train/utils/ppo_utils.py:494-510`</summary>

```python
    @classmethod
    def repopulate_registry(cls):
        """Repopulate the registry with default policy loss functions."""
        pl_avail = set(cls.list_available())
        pl_types = {
            "regular": [PolicyLossType.REGULAR, ppo_policy_loss],
            "dual_clip": [PolicyLossType.DUAL_CLIP, ppo_policy_loss],
            "gspo": [PolicyLossType.GSPO, gspo_policy_loss],
            "clip_cov": [PolicyLossType.CLIP_COV, compute_policy_loss_clip_cov],
            "kl_cov": [PolicyLossType.KL_COV, compute_policy_loss_kl_cov],
            "sapo": [PolicyLossType.SAPO, sapo_policy_loss],
            "cross_entropy": [PolicyLossType.CROSS_ENTROPY, cross_entropy_loss],
        }

        for pl_name, (pl_type, pl_func) in pl_types.items():
            if pl_name not in pl_avail:
                cls.register(pl_type, pl_func)
```

</details>

### <span className="bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">class</span> `PolicyLossType`

Bases: StrEnum

**Functions:**

Name | Description
---- | -----------
[`__new__`](#__new__) |
[`__format__`](#__format__) | Return a formatted version of the string as described by format_spec.
[`__repr__`](#__repr__) |
[`__str__`](#__str__) | Return str(self).

**Attributes:**

Name | Type | Description
---- | ---- | -----------
[`__doc__`](#__doc__) | | str(object='') -> str
[`__module__`](#__module__) | | str(object='') -> str

#### <span className="bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">attr</span> `__doc__`

```python
__doc__ = '\n    Enum where members are also (and must be) strings\n    '
```

str(object='') -> str
str(bytes_or_buffer\[, encoding[, errors]\]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

#### <span className="bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">attr</span> `__module__`

```python
__module__ = 'enum'
```

str(object='') -> str
str(bytes_or_buffer\[, encoding[, errors]\]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> <span className="bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">staticmethod</span> `__new__`

```python
__new__(value)
```

#### `__format__`

```python
__format__(format_spec)
```

Return a formatted version of the string as described by format_spec.

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> `__repr__`

```python
__repr__()
```

#### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> `__str__`

```python
__str__()
```

Return str(self).

### <span className="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 inline-block px-1.5 py-0.5 rounded text-xs font-medium align-middle">method</span> `register_policy_loss`

```python
register_policy_loss(name: Union[str, PolicyLossType])
```

Decorator to register a policy loss function.
